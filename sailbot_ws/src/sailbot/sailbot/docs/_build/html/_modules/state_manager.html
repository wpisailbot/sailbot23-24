<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>state_manager &#8212; sailbot 1.0.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=4f649999" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=af2ce170"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for state_manager</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">rclpy</span>
<span class="kn">from</span> <span class="nn">rclpy.node</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">rclpy.client</span> <span class="kn">import</span> <span class="n">Client</span>
<span class="kn">from</span> <span class="nn">lifecycle_msgs.srv</span> <span class="kn">import</span> <span class="n">GetState</span><span class="p">,</span> <span class="n">ChangeState</span>
<span class="kn">from</span> <span class="nn">lifecycle_msgs.msg</span> <span class="kn">import</span> <span class="n">State</span><span class="p">,</span> <span class="n">Transition</span>
<span class="kn">from</span> <span class="nn">rclpy.executors</span> <span class="kn">import</span> <span class="n">MultiThreadedExecutor</span><span class="p">,</span> <span class="n">SingleThreadedExecutor</span>
<span class="kn">from</span> <span class="nn">rclpy.callback_groups</span> <span class="kn">import</span> <span class="n">MutuallyExclusiveCallbackGroup</span><span class="p">,</span> <span class="n">ReentrantCallbackGroup</span>
<span class="kn">from</span> <span class="nn">sailbot_msgs.srv</span> <span class="kn">import</span> <span class="n">RestartNode</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">asyncio</span> <span class="kn">import</span> <span class="n">Future</span>
<span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Event</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">traceback</span>

<div class="viewcode-block" id="StateManager"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager">[docs]</a><span class="k">class</span> <span class="nc">StateManager</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A ROS2 node that manages the lifecycle states of other nodes within the system. It provides services for restarting</span>
<span class="sd">    nodes and functions to transition nodes between different lifecycle states. This manager supports nodes defined</span>
<span class="sd">    as managed and can ensure that they are initialized in the correct state during system startup.</span>

<span class="sd">    :ivar early_node_names: A list of node names that should be managed before others upon system start.</span>
<span class="sd">    :ivar node_names: A list of all other node names to be managed.</span>
<span class="sd">    :ivar client_state_getters: Dictionary mapping node names to ROS2 clients for getting current state.</span>
<span class="sd">    :ivar client_state_setters: Dictionary mapping node names to ROS2 clients for setting state.</span>

<span class="sd">    **Service Servers**:</span>

<span class="sd">    - &#39;restart_node_srv&#39;: A service that allows external requests to restart managed nodes.</span>

<span class="sd">    **Methods**:</span>

<span class="sd">    - &#39;configure_nodes&#39;: Configures a list of nodes using their transition services.</span>
<span class="sd">    - &#39;activate_nodes&#39;: Activates a list of nodes, bringing them from the configured state to active.</span>
<span class="sd">    - &#39;transitionNodes&#39;: Manages the state transitions for a list of nodes based on specified transition IDs.</span>
<span class="sd">    - &#39;restart_lifecycle_node_callback&#39;: Callback for the service that handles requests to restart nodes.</span>
<span class="sd">    - &#39;restart_node&#39;: Handles the actual restart of a node by managing its state transitions.</span>
<span class="sd">    - &#39;get_node_state&#39;: Retrieves the current state of a node.</span>
<span class="sd">    - &#39;change_node_state&#39;: Asynchronously changes the state of a node.</span>
<span class="sd">    - &#39;change_node_state_sync&#39;: Synchronously changes the state of a node, suitable for calling from other ROS2 callbacks.</span>

<span class="sd">    **Usage**:</span>

<span class="sd">    - This node is initialized and run using a ROS2 launch file and interacts with other nodes through service calls to manage their states according to system requirements or external inputs.</span>

<span class="sd">    **Notes**:</span>

<span class="sd">    - The manager must be aware of all nodes it needs to manage, configured through the managed_nodes parameter.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">early_node_names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;network_comms&quot;</span><span class="p">]</span>
    <span class="n">node_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">client_state_getters</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">client_state_setters</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Client</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;state_manager&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;starting manager&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">declare_parameter</span><span class="p">(</span><span class="s1">&#39;managed_nodes&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_parameter</span><span class="p">(</span><span class="s1">&#39;managed_nodes&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">get_parameter_value</span><span class="p">()</span><span class="o">.</span><span class="n">string_array_value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Managed nodes: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">node_names</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback_group_input</span> <span class="o">=</span> <span class="n">ReentrantCallbackGroup</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback_group_state</span> <span class="o">=</span> <span class="n">ReentrantCallbackGroup</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">restart_node_srv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_service</span><span class="p">(</span><span class="n">RestartNode</span><span class="p">,</span> <span class="s1">&#39;state_manager/restart_node&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">restart_lifecycle_node_callback</span><span class="p">,</span> <span class="n">callback_group</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">callback_group_input</span><span class="p">)</span>

        <span class="c1">#create service clients for each node</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">early_node_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_state_getters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_client</span><span class="p">(</span><span class="n">GetState</span><span class="p">,</span> <span class="n">name</span><span class="o">+</span><span class="s2">&quot;/get_state&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_state_setters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_client</span><span class="p">(</span><span class="n">ChangeState</span><span class="p">,</span> <span class="n">name</span><span class="o">+</span><span class="s2">&quot;/change_state&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">node_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_state_getters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_client</span><span class="p">(</span><span class="n">GetState</span><span class="p">,</span> <span class="n">name</span><span class="o">+</span><span class="s2">&quot;/get_state&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_state_setters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_client</span><span class="p">(</span><span class="n">ChangeState</span><span class="p">,</span> <span class="n">name</span><span class="o">+</span><span class="s2">&quot;/change_state&quot;</span><span class="p">)</span>
        
        <span class="c1">#run async function to move nodes to configured state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Configuring&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">early_node_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Activating&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activate_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">early_node_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">configure_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_names</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activate_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">node_names</span><span class="p">)</span>
        <span class="c1">#self.timer = self.create_timer(2, self.timer_callback)</span>

    <span class="c1"># Can sometimes get stuck? It&#39;s rare, but maybe just move to sequential, or find source of deadlock</span>
<div class="viewcode-block" id="StateManager.transitionNodes"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager.transitionNodes">[docs]</a>    <span class="k">def</span> <span class="nf">transitionNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">transition_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="c1">#assemble and run list of async configure transition calls</span>
        <span class="n">failed_names</span> <span class="o">=</span> <span class="n">node_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1">#retry any which failed because the service was unavailable (timing issue, any other way to resolve?)</span>
        <span class="k">while</span> <span class="n">failed_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Failed names: &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">failed_names</span><span class="p">))</span>
            <span class="n">func_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">change_node_state</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">transition_id</span><span class="p">)</span> <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">failed_names</span><span class="p">]</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">func_list</span><span class="p">]</span>
            <span class="n">zipped</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">failed_names</span><span class="p">)</span>
            <span class="n">new_failed_names</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">result</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">zipped</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="s2">&quot;, &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">new_failed_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Failed: &quot;</span><span class="o">+</span><span class="n">name</span><span class="p">)</span>
            <span class="n">failed_names</span> <span class="o">=</span> <span class="n">new_failed_names</span>

        <span class="k">return</span> <span class="kc">True</span></div>
    
<div class="viewcode-block" id="StateManager.restart_lifecycle_node_callback"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager.restart_lifecycle_node_callback">[docs]</a>    <span class="k">def</span> <span class="nf">restart_lifecycle_node_callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
        <span class="n">node_name</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">node_name</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restart_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
            <span class="n">response</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">response</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Node </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s2"> restarted successfully.&quot;</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">response</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">response</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">response</span></div>

<div class="viewcode-block" id="StateManager.restart_node"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager.restart_node">[docs]</a>    <span class="k">def</span> <span class="nf">restart_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manages the state transitions of a specified lifecycle node to effectively restart it. This function checks the</span>
<span class="sd">        current state of the node and applies the necessary transitions to bring it to an active state from any other state.</span>

<span class="sd">        :param node_name: The name of the node whose state needs to be managed.</span>

<span class="sd">        :return: None. This function directly affects the state of the node by sending transition commands based on its current state.</span>

<span class="sd">        Function behavior includes:</span>
<span class="sd">        - Retrieving the current state of the node.</span>
<span class="sd">        - Logging the current state for monitoring and debugging purposes.</span>
<span class="sd">        - Applying a series of state transitions to restart the node:</span>
<span class="sd">        - If the node is &#39;active&#39;, it will be deactivated, cleaned up, configured, and reactivated.</span>
<span class="sd">        - If the node is &#39;inactive&#39;, it will be cleaned up, configured, and activated.</span>
<span class="sd">        - If the node is in &#39;finalized&#39; or &#39;unconfigured&#39; state, it will be configured and activated.</span>
<span class="sd">        - If the node is in an unknown state, a log message will be generated indicating this.</span>
<span class="sd">        - These transitions are designed to ensure that the node can recover from any stable state to active status.</span>

<span class="sd">        The function relies on the &#39;change_node_state_sync&#39; method to perform the state transitions, which sends requests to</span>
<span class="sd">        the node to change its state according to the ROS2 lifecycle state machine. Each transition is logged to provide a clear</span>
<span class="sd">        trace of the actions taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Getting node state&quot;</span><span class="p">)</span>
        <span class="n">current_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_state</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current state: </span><span class="si">{</span><span class="n">current_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Setting node state&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">current_state</span> <span class="o">==</span> <span class="s1">&#39;active&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_DEACTIVATE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_CLEANUP</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_CONFIGURE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_ACTIVATE</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">current_state</span> <span class="o">==</span> <span class="s1">&#39;inactive&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_CLEANUP</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_CONFIGURE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_ACTIVATE</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">current_state</span> <span class="o">==</span> <span class="s1">&#39;finalized&#39;</span> <span class="ow">or</span> <span class="n">current_state</span> <span class="o">==</span> <span class="s1">&#39;unconfigured&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_CONFIGURE</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_node_state_sync</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_ACTIVATE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Node </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1"> is in an unknown state: </span><span class="si">{</span><span class="n">current_state</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

        

<div class="viewcode-block" id="StateManager.configure_nodes"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager.configure_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">configure_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Configuring </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitionNodes</span><span class="p">(</span><span class="n">node_names</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_CONFIGURE</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="StateManager.activate_nodes"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager.activate_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">activate_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_names</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;activating </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">node_names</span><span class="p">)</span><span class="si">}</span><span class="s2"> nodes&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitionNodes</span><span class="p">(</span><span class="n">node_names</span><span class="p">,</span> <span class="n">Transition</span><span class="o">.</span><span class="n">TRANSITION_ACTIVATE</span><span class="p">)</span></div>

<div class="viewcode-block" id="StateManager.get_node_state"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager.get_node_state">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the current state of a specified node using a ROS2 service call. If the service is not available within three seconds,</span>
<span class="sd">        returns &#39;unknown&#39;.</span>

<span class="sd">        :param node_name: The name of the node whose state is to be retrieved.</span>

<span class="sd">        :return: The label of the current state of the node as a string, or &#39;unknown&#39; if the service is not available within the timeout.</span>

<span class="sd">        Function behavior includes:</span>
<span class="sd">        - Checking the availability of the &#39;GetState&#39; service for the specified node up to three times, with one second wait each.</span>
<span class="sd">        - If the service becomes available, sending a request to obtain the current state of the node.</span>
<span class="sd">        - If the service is not available within three attempts, returning &#39;unknown&#39;.</span>
<span class="sd">        - Logging each attempt to connect to the service and the outcome.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a service client for GetState</span>
        <span class="n">cli</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_state_getters</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span><span class="c1">#self.create_client(GetState, f&#39;{node_name}/get_state&#39;)</span>
        <span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">cli</span><span class="o">.</span><span class="n">wait_for_service</span><span class="p">(</span><span class="n">timeout_sec</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
            <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attempt </span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s1">: Waiting for </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1"> GetState service...&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attempts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;GetState service not available!.&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="s1">&#39;unknown&#39;</span>
        
        <span class="n">request</span> <span class="o">=</span> <span class="n">GetState</span><span class="o">.</span><span class="n">Request</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cli</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">current_state</span><span class="o">.</span><span class="n">label</span></div>


<div class="viewcode-block" id="StateManager.change_node_state"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager.change_node_state">[docs]</a>    <span class="k">def</span> <span class="nf">change_node_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">transition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends a request to change the state of a specified node via a ROS2 service call. This function manages node transitions</span>
<span class="sd">        using the ROS2 lifecycle protocol by interacting with a service dedicated to changing node states. </span>
<span class="sd">        This function should NOT be used from ROS2 callbacks- timers, subscriptions, service callbacks, etc, as the async spin </span>
<span class="sd">        WILL deadlock this node. This is used at startup to launch many nodes simultaneously. Callbacks should instead use change_node_state_sync.</span>

<span class="sd">        :param node_name: The name of the node whose state is to be changed.</span>
<span class="sd">        :param transition: The transition ID that needs to be applied to the node. This ID should correspond to one of the</span>
<span class="sd">                        predefined transition states in the ROS2 lifecycle.</span>

<span class="sd">        :return: A boolean value indicating the success or failure of the state change. Returns True if the state transition was</span>
<span class="sd">                successful, False otherwise.</span>

<span class="sd">        Function behavior includes:</span>
<span class="sd">        - Checking for the availability of the service that allows state changes for the specified node. If the service is not</span>
<span class="sd">        available immediately, it waits up to one second for it to become available.</span>
<span class="sd">        - Creating and sending a request to change the state of the node based on the specified transition.</span>
<span class="sd">        - Using asynchronous service calls to request the transition and waiting for the call to complete.</span>
<span class="sd">        - Logging the process and outcome of the service call, including waiting for the service, the attempt to change state,</span>
<span class="sd">        and the result of the call.</span>

<span class="sd">        This function assumes that a client for the node-specific &#39;ChangeState&#39; service has already been set up in &#39;client_state_setters&#39;.</span>
<span class="sd">        It handles possible delays in service availability and logs significant actions and outcomes to aid in debugging and monitoring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a service client for ChangeState</span>
        <span class="n">cli</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_state_setters</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span>
        <span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">cli</span><span class="o">.</span><span class="n">wait_for_service</span><span class="p">(</span><span class="n">timeout_sec</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
            <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attempt </span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s1">: Waiting for </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1"> ChangeState service...&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attempts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;ChangeState service not available!.&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">request</span> <span class="o">=</span> <span class="n">ChangeState</span><span class="o">.</span><span class="n">Request</span><span class="p">()</span>
        <span class="n">request</span><span class="o">.</span><span class="n">transition</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">transition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Before call&quot;</span><span class="p">)</span>
        <span class="n">future</span> <span class="o">=</span> <span class="n">cli</span><span class="o">.</span><span class="n">call_async</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
        <span class="n">rclpy</span><span class="o">.</span><span class="n">spin_until_future_complete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">future</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;State changed successfully in </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Failed to call change_state service&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="StateManager.change_node_state_sync"><a class="viewcode-back" href="../state_manager.html#state_manager.StateManager.change_node_state_sync">[docs]</a>    <span class="k">def</span> <span class="nf">change_node_state_sync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">transition</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sends a request to change the state of a specified node via a ROS2 service call. This function manages node transitions</span>
<span class="sd">        using the ROS2 lifecycle protocol by interacting with a service dedicated to changing node states. </span>
<span class="sd">        This function is intended for use in callbacks, and will not deadlock this node.</span>

<span class="sd">        :param node_name: The name of the node whose state is to be changed.</span>
<span class="sd">        :param transition: The transition ID that needs to be applied to the node. This ID should correspond to one of the</span>
<span class="sd">                        predefined transition states in the ROS2 lifecycle.</span>

<span class="sd">        :return: A boolean value indicating the success or failure of the state change. Returns True if the state transition was</span>
<span class="sd">                successful, False otherwise.</span>

<span class="sd">        Function behavior includes:</span>
<span class="sd">        - Checking for the availability of the service that allows state changes for the specified node. If the service is not</span>
<span class="sd">        available immediately, it waits up to one second for it to become available.</span>
<span class="sd">        - Creating and sending a request to change the state of the node based on the specified transition.</span>
<span class="sd">        - Using synchronous service calls to request the transition.</span>
<span class="sd">        - Logging the process and outcome of the service call, including waiting for the service, the attempt to change state,</span>
<span class="sd">        and the result of the call.</span>

<span class="sd">        This function assumes that a client for the node-specific &#39;ChangeState&#39; service has already been set up in &#39;client_state_setters&#39;.</span>
<span class="sd">        It handles possible delays in service availability and logs significant actions and outcomes to aid in debugging and monitoring.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a service client for ChangeState</span>
        <span class="n">cli</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_state_setters</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span>
        <span class="n">attempts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">cli</span><span class="o">.</span><span class="n">wait_for_service</span><span class="p">(</span><span class="n">timeout_sec</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
            <span class="n">attempts</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Attempt </span><span class="si">{</span><span class="n">attempts</span><span class="si">}</span><span class="s1">: Waiting for </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1"> ChangeState service...&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attempts</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;ChangeState service not available!.&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
        
        <span class="n">request</span> <span class="o">=</span> <span class="n">ChangeState</span><span class="o">.</span><span class="n">Request</span><span class="p">()</span>
        <span class="n">request</span><span class="o">.</span><span class="n">transition</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">transition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Before call&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">cli</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;State changed successfully in </span><span class="si">{</span><span class="n">node_name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Failed to call change_state service&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span></div></div>
            

<div class="viewcode-block" id="main"><a class="viewcode-back" href="../state_manager.html#state_manager.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">rclpy</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
    <span class="n">state_manager</span> <span class="o">=</span> <span class="n">StateManager</span><span class="p">()</span>

    <span class="c1"># Use the SingleThreadedExecutor to spin the node.</span>
    <span class="n">executor</span> <span class="o">=</span> <span class="n">MultiThreadedExecutor</span><span class="p">()</span>
    <span class="n">executor</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">state_manager</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Spin the node to execute callbacks</span>
        <span class="n">executor</span><span class="o">.</span><span class="n">spin</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">trace</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">format_exc</span><span class="p">()</span>
        <span class="n">state_manager</span><span class="o">.</span><span class="n">get_logger</span><span class="p">()</span><span class="o">.</span><span class="n">fatal</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Unhandled exception: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">trace</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="c1"># Shutdown and cleanup the node</span>
        <span class="n">executor</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
        <span class="n">state_manager</span><span class="o">.</span><span class="n">destroy_node</span><span class="p">()</span>
        <span class="n">rclpy</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span></div>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">sailbot</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../airmar_reader.html">Airmar Reader Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ballast_control.html">Ballast Control Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../buoy_detection.html">Buoy Detection Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../esp32_comms.html">ESP32 Comms Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../heading_controller_vf.html">Heading Controller Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../network_comms.html">Network Comms Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../path_follower_vf.html">Path Follower Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../state_manager.html">State Manager Node</a></li>
<li class="toctree-l1"><a class="reference internal" href="../wind_smoother.html">Wind Smoother Node</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, Matthew Gomes.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>